#!/usr/bin/env python
import json, sys, os, re, shutil, shlex
from distutils.util import strtobool
from subprocess import call, check_output, CalledProcessError

SCRIPT_ROOT_DIR = os.path.dirname(os.path.realpath(__file__))
SRC_DIR = os.path.join(SCRIPT_ROOT_DIR, 'src')
BIN_DIR = os.path.join(SCRIPT_ROOT_DIR, 'bin')
GBL = 'global'
DPND = 'depends-on'
NAME = 'name'
TRG_DIR = 'install-target'
PKG_URL = 'pkg-url'
PKGS = 'packages'
RECIPE = 'recipe'

class Dependency:
    def __init__(self, name='dep', recipe=[]):
        self.name = name
        self.recipe = recipe

    def to_json(self):
        res = json.dumps(self, default=lambda o: o.__dict__)
        # Convert python variable names to json variable names
        return res.replace('_', '-')

    def to_dict(self):
        # Convert python variable names to json variable names
        return {k.replace('_', '-'): v for k,v in self.__dict__.items()}


class VimPackage:
    def __init__(self, pkg_url='', depends_on=[], recipe=[]):
        self.pkg_url = pkg_url
        self.depends_on = depends_on
        self.recipe = recipe

    def to_json(self):
        res = json.dumps(self, default=lambda o: o.__dict__)
        # Convert python variable names to json variable names
        return res.replace('_', '-')

    def to_dict(self):
        # Convert python variable names to json variable names
        d = {k.replace('_', '-'): v for k,v in self.__dict__.items()}
        deps = [ dep.to_dict() for dep in self.depends_on ]
        d[DPND] = deps
        return d

def load_vim_config(file_path='~/.vimpkg/vim_config.json'):
    json_file = open(file_path).read()
    return json.loads(json_file)

def get_global_requirements(vim_config):
    return [ req[NAME] for req in vim_config[GBL][DPND] ]

#def run_post_install(git_url, commands=[]):
    #for command in commands:
        #try:
            #call(command)
        #except:
            #report_fail(
                    #'Failed to complete post-install for `' + git_url + '`' +
                    #'\nCommand `' + str(' '.join(command)) + '` failed.'
                    #)

def status_update(pkg_name):
    print '\nCloning, configuring, and installing `' + pkg_name + '`'

def install_pkg(git_url, vim_config):
    #TODO: add git_url and post-install to vim_config.json
    global SCRIPT_ROOT_DIR
    vimpkg = VimPackage(pkg_url=git_url)
    pkg_name = get_pkg_name_from_url(git_url)
    #if TRG_DIR in vim_config[GBL]:
        #install_target = vim_config[GBL][TRG_DIR]
    #else:
        #install_target = '~/.vim/bundle'
    install_target = os.path.join(SCRIPT_ROOT_DIR, vim_config[GBL][TRG_DIR])

    if os.path.exists(os.path.join(install_target, pkg_name)) or \
            git_url in [p[PKG_URL] for p in vim_config[PKGS]]:
        confirm_install(pkg_name, install_target, git_url, vim_config)

    status_update(pkg_name)
    # Get dependencies of package
    depends = get_depend()
    vimpkg.depends_on = depends

    msg = 'Any commands to run after cloning `' + pkg_name + '`?'
    post_install_recipe = get_recipe(msg)
    vimpkg.recipe = post_install_recipe

    # Install dependencies of package
    install_dependencies(pkg_name, depends)
    # Clone the plugin and run any post-install commands
    __install_pkg(pkg_name, git_url, install_target, post_install_recipe)
    # Change back to the DIR containing this script
    os.chdir(SCRIPT_ROOT_DIR)
    return vimpkg

def clone_pkg(git_url):
    pkg_name = get_pkg_name_from_url(git_url)
    try:
        call(['git', 'clone', git_url])
    except:
        report_fail('Failed to clone `' + pkg_name + '`')

def __install_pkg(pkg_name, git_url, install_target, commands=[]):
    # Change to directory with vim plugins
    os.chdir(install_target)
    clone_pkg(git_url)
    os.chdir(pkg_name)
    if not exe_shell_commands(commands):
        report_fail('Failed to intall ' + pkg_name)

def install_dependencies(pkg_name, dependencies=[]):
    global SRC_DIR
    for dep in dependencies:
        # Change to directory with dependency source
        os.chdir(SRC_DIR)
        if not os.path.exists(pkg_name):
            os.makedirs(pkg_name)
        os.chdir(pkg_name)

        commands = dep.recipe
        if not exe_shell_commands(commands):
            report_fail('Failed to intall ' + pkg_name)

def user_confirm(msg=None):
    if msg is None:
        msg = 'Do you wish to continue anyways?'
    msg += ' [y|N]:  '
    num_tries = 0
    while num_tries < 3:
        try:
            user_choice = raw_input(msg).strip().lower()
            if strtobool(user_choice):
                return True
            return False
        except:  # Invalid option, retry
            print 'Invalid option. Please enter `Y` or `N` only'
            num_tries += 1
    return False

def report_fail(fail_msg=None, confirm_msg=None, confirm_continue=True):
    if fail_msg is None:
        fail_msg = 'Something went wrong...\n'
    print fail_msg
    if confirm_continue:
        if user_confirm(confirm_msg):
            return True
    sys.exit(1)

def confirm_install(pkg_name, install_target, git_url, vim_config):
    if report_fail('Package `' + pkg_name + '` already exists. Do you wish to overwrite?'):
        # Delete plugin and its dependencies/src
        remove_pkg(pkg_name, install_target, vim_config)
        # Delete package from json
        vim_config[PKGS] = remove_pkg_ref(git_url, vim_config)
        return True
    return False

def remove_pkg(pkg_name, install_target, vim_config):
    remove_pkg_src(pkg_name)
    remove_pkg_plugin(pkg_name, install_target)
    #TODO: check all dependencies related to pkg_name
    # If no other package depends on this binary, remove it
    #if pkg_name not in [ dep[NAME] for dep in [p[DPND] for p in remove_pkg_ref(git_url, vim_config)]] ]:
        #remove_pkg_bin(pkg_name)

def remove_dir(dir):
    if os.path.exists(dir):
        shutil.rmtree(dir)

def remove_pkg_bin(pkg_name):
    dir = os.path.join(BIN_DIR, pkg_name)
    remove_dir(dir)

def remove_pkg_src(pkg_name):
    dir = os.path.join(SRC_DIR, pkg_name)
    remove_dir(dir)

def remove_pkg_ref(git_url, vim_config):
    return [ p for p in vim_config[PKGS] if p[PKG_URL] != git_url ]

def remove_pkg_plugin(pkg_name, install_target):
    dir = os.path.join(install_target, pkg_name)
    remove_dir(dir)


def get_depend():
    depends = []
    if user_confirm('Does this plugin have any Dependencies?'):
        i = 1;
        dep_name = raw_input('Name for dependency ' + str(i) + ':  ')
        while dep_name != "":
            depends.append(__get_depend(dep_name))
            i += 1
            dep_name = raw_input('Name for dependency ' + str(i) + ':  ')
    return depends

def __get_depend(name):
    dep = Dependency(name)
    #msg = 'Any commands to run to install Dependency?'
    #dep.recipe = get_recipe(msg)
    dep.recipe = get_recipe()
    return dep

def get_recipe(msg=None):
    if msg is None:
        return __get_recipe()

    if user_confirm(msg):
        return  __get_recipe()
    else:
        return []

def __get_recipe():
    commands = []
    print '\nEnter commands one line at a time. ' + \
            'Terminate commands with an empty line.'
    i = 1
    command = raw_input('Command ' + str(i) + ': ')
    while command != "":
        i += 1
        commands.append(command)
        command = raw_input('Command ' + str(i) + ': ')
    return commands

def save_vim_config(vim_config, vimpkg, file_path=None):
    if file_path is None:
        file_path = os.path.join(SCRIPT_ROOT_DIR, 'vim_config.json')
    try:
        with open(file_path) as f:
            data = json.load(f)

        data[PKGS].append(vimpkg.to_dict())
        with open(file_path, 'w') as f:
            json.dump(data, f, sort_keys=True, indent=4, separators=(',', ': '))
    except:
        print 'failed to write ' + file_path
        sys.exit(1)

def get_pkg_name_from_url(git_url):
    pkg_regex = re.compile(r'.*\/([^\/]+).git$')
    match = pkg_regex.match(git_url)
    return match.group(1)

def check_requirements(requirements=None):
    if requirements is None:
        return True
    for req in requirements:
        try:
            call(['which', req])
        except:
            print 'Missing requirement: ' + req
            return False
    return True

def validate_url(url):
    regex = re.compile(
            r'^(?:http|ftp)s?://' # http:// or https:// or ftp:// or ftps://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    match = regex.search(url)
    return True if match else False

def usage():
    pass

def process_cmd_args(git_url):
    #TODO: use below to verify git_url if one is expected (i.e. for apt-vim install)
    argv = sys.argv
    argc = len(argv)
    # Get git url (try last argument in argv)
    git_url = argv[argc -1]
    if validate_url(git_url):
        #TODO: process command
        pass
    else:
        usage()
        sys.exit()

def exe_shell_commands(commands=None):
    if commands is None:
        commands = []
    for com in commands:
        try:
            if 'cd' in com:
                os.chdir(shlex.split(com)[1])
            else:
                call(shlex.split(com))
        except:
            return report_fail('Command `' + com + '` failed.')
    return True

def init(vim_config):
    missing_deps = []
    deps = vim_config[DPND]
    for dep in deps:
        if not check_requirements([dep[NAME]]):
            if not exe_shell_commands(dep[recipe]):
                missing_deps.append(dep[NAME])
    return missing_deps

def usage():
    pass

def main():
    vim_config = load_vim_config('./vim_config.json')
    missing_dependencies = init(vim_config)
    if missing_dependencies:
        print 'Cannot proceed. Missing the following dependencies that could' \
                + ' not be automatically insatlled:\n' \
                + str(missing_dependencies)

    vimpkg = install_pkg('https://github.com/majutsushi/tagbar.git', vim_config)
    save_vim_config(vim_config, vimpkg)


if __name__ == '__main__':
    main()
