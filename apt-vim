#!/usr/bin/env python
import json, sys, os, re, shutil, shlex
from distutils.util import strtobool
from subprocess import call, check_output, CalledProcessError

SCRIPT_ROOT_DIR = os.path.dirname(os.path.realpath(__file__))
SRC_DIR = os.path.join(SCRIPT_ROOT_DIR, 'src')
BIN_DIR = os.path.join(SCRIPT_ROOT_DIR, 'bin')
GBL = 'global'
DPND = 'depends-on'
NAME = 'name'
TRG_DIR = 'install-target'
PKG_URL = 'pkg-url'
PKGS = 'packages'
RECIPE = 'recipe'
VIM_CONFIG = os.path.join(SCRIPT_ROOT_DIR, 'vim_config.json')

class Dependency:
    def __init__(self, name='dep', recipe=[]):
        self.name = name
        self.recipe = recipe

    def to_json(self):
        res = json.dumps(self, default=lambda o: o.__dict__)
        # Convert python variable names to json variable names
        return res.replace('_', '-')

    def to_dict(self):
        # Convert python variable names to json variable names
        return {k.replace('_', '-'): v for k,v in self.__dict__.items()}


class VimPackage:
    def __init__(self, pkg_url='', name='', depends_on=[], recipe=[]):
        self.pkg_url = pkg_url
        self.name = name
        self.depends_on = depends_on
        self.recipe = recipe

    def to_json(self):
        res = json.dumps(self, default=lambda o: o.__dict__)
        # Convert python variable names to json variable names
        return res.replace('_', '-')

    def to_dict(self):
        # Convert python variable names to json variable names
        d = {k.replace('_', '-'): v for k,v in self.__dict__.items()}
        deps = [ dep.to_dict() for dep in self.depends_on ]
        d[DPND] = deps
        return d


def load_vim_config(file_path=VIM_CONFIG):
    json_file = open(file_path).read()
    return json.loads(json_file)

def get_install_target():
    vim_config = load_vim_config()
    return os.path.join(SCRIPT_ROOT_DIR, vim_config[GBL][TRG_DIR])

def get_global_requirements(vim_config):
    return [ req[NAME] for req in vim_config[GBL][DPND] ]

def status_update(pkg_name):
    print '\nCloning, configuring, and installing `' + pkg_name + '`'

def install_pkg(vimpkg):
    install_target = get_install_target()
    # Install dependencies of package
    install_dependencies(vimpkg.name, vimpkg.depends_on)
    # Clone the plugin and run any post-install commands
    __install_pkg(vimpkg.name, vimpkg.pkg_url, install_target, vimpkg.recipe)
    # Change back to the DIR containing this script
    os.chdir(SCRIPT_ROOT_DIR)
    return vimpkg

def add_pkg(git_url, vim_config):
    #TODO: add git_url and post-install to vim_config.json
    vimpkg = VimPackage(pkg_url=git_url)
    pkg_name = get_pkg_name_from_url(git_url)
    vimpkg.name = pkg_name
    install_target = get_install_target()

    if os.path.exists(os.path.join(install_target, pkg_name)): # or \
            #git_url in [p[PKG_URL] for p in vim_config[PKGS]]:
        print 'Skipping installed package `' + pkg_name + '`'
        print 'To re-install `' + pkg_name + '` run:' \
                + '\n\t`apt-vim remove ' + pkg_name + '`' \
                + '\n\t`apt-vim install ' + git_url + '`'
        sys.exit(0)
        #confirm_install(pkg_name, install_target, git_url, vim_config)

    status_update(pkg_name)
    # Get dependencies of package
    depends = get_depend()
    vimpkg.depends_on = depends

    msg = 'Any commands to run after cloning `' + pkg_name + '`?'
    post_install_recipe = get_recipe(msg)
    vimpkg.recipe = post_install_recipe
    return vimpkg

def clone_pkg(git_url):
    pkg_name = get_pkg_name_from_url(git_url)
    try:
        call(['git', 'clone', git_url])
    except:
        report_fail('Failed to clone `' + pkg_name + '`')

def __install_pkg(pkg_name, git_url, install_target, commands=[]):
    # Change to directory with vim plugins
    os.chdir(install_target)
    clone_pkg(git_url)
    os.chdir(pkg_name)
    if not exe_shell_commands(commands):
        report_fail('Failed to intall ' + pkg_name)

def install_dependencies(pkg_name, dependencies=[]):
    for dep in dependencies:
        # Change to directory with dependency source
        os.chdir(SRC_DIR)
        if not os.path.exists(pkg_name):
            os.makedirs(pkg_name)
        os.chdir(pkg_name)

        commands = dep.recipe
        if not exe_shell_commands(commands):
            report_fail('Failed to intall ' + pkg_name)

def user_confirm(msg=None):
    if msg is None:
        msg = 'Do you wish to continue anyways?'
    msg += ' [y|N]:  '
    num_tries = 0
    while num_tries < 3:
        try:
            user_choice = raw_input(msg).strip().lower()
            if strtobool(user_choice):
                return True
            return False
        except:  # Invalid option, retry
            print 'Invalid option. Please enter `Y` or `N` only'
            num_tries += 1
    return False

def report_fail(fail_msg=None, confirm_msg=None, confirm_continue=True):
    if fail_msg is None:
        fail_msg = 'Something went wrong...\n'
    print fail_msg
    if confirm_continue:
        if user_confirm(confirm_msg):
            return True
    sys.exit(1)

def confirm_install(pkg_name, install_target, git_url, vim_config):
    if report_fail('Package `' + pkg_name + '` already exists. Do you wish to overwrite?'):
        # Delete plugin and its dependencies/src, delete package from json
        vim_config[PKGS] = remove_pkg(pkg_name, git_url, install_target, vim_config)
        return True
    return False

def remove_pkg(pkg_name, git_url, install_target, vim_config):
    remove_pkg_src(pkg_name)
    remove_pkg_plugin(pkg_name, install_target)
    #TODO: check all dependencies related to pkg_name
    # If no other package depends on this binary, remove it
    #if pkg_name not in [ dep[NAME] for dep in [p[DPND] for p in remove_pkg_ref(git_url, vim_config)]] ]:
        #remove_pkg_bin(pkg_name)
    return remove_pkg_ref(git_url, vim_config)

def remove_dir(dir):
    if os.path.exists(dir):
        shutil.rmtree(dir)

def remove_pkg_bin(pkg_name):
    dir = os.path.join(BIN_DIR, pkg_name)
    remove_dir(dir)

def remove_pkg_src(pkg_name):
    dir = os.path.join(SRC_DIR, pkg_name)
    remove_dir(dir)

def remove_pkg_ref(pkg_name, vim_config):
    return [ p for p in vim_config[PKGS] if pkg_name not in p[PKG_URL] ]

def remove_pkg_plugin(pkg_name, install_target):
    dir = os.path.join(install_target, pkg_name)
    remove_dir(dir)


def get_depend():
    depends = []
    if user_confirm('Does this plugin have any Dependencies?'):
        i = 1;
        dep_name = raw_input('Name for dependency ' + str(i) + ':  ')
        while dep_name != "":
            depends.append(__get_depend(dep_name))
            i += 1
            dep_name = raw_input('Name for dependency ' + str(i) + ':  ')
    return depends

def __get_depend(name):
    dep = Dependency(name)
    #msg = 'Any commands to run to install Dependency?'
    #dep.recipe = get_recipe(msg)
    dep.recipe = get_recipe()
    return dep

def get_recipe(msg=None):
    if msg is None:
        return __get_recipe()

    if user_confirm(msg):
        return  __get_recipe()
    else:
        return []

def __get_recipe():
    commands = []
    print '\nEnter commands one line at a time. ' + \
            'Terminate commands with an empty line.'
    i = 1
    command = raw_input('Command ' + str(i) + ': ')
    while command != "":
        i += 1
        commands.append(command)
        command = raw_input('Command ' + str(i) + ': ')
    return commands

def save_vim_config(vim_config, vimpkg=None, file_path=None):
    if file_path is None:
        file_path = os.path.join(SCRIPT_ROOT_DIR, 'vim_config.json')
    try:
        with open(file_path) as f:
            data = json.load(f)

        if vimpkg:
            vim_config[PKGS].append(vimpkg.to_dict())
        data[PKGS] = vim_config[PKGS]
        with open(file_path, 'w') as f:
            json.dump(data, f, sort_keys=True, indent=4, separators=(',', ': '))
    except:
        print 'failed to write ' + file_path
        sys.exit(1)

def get_pkg_name_from_url(git_url):
    pkg_regex = re.compile(r'.*\/([^\/]+).git$')
    match = pkg_regex.match(git_url)
    if match:
        return match.group(1)
    return None

def check_requirements(requirements=None):
    if requirements is None:
        return True
    for req in requirements:
        try:
            call(['which', req], stdout=open(os.devnull, 'wb'))
        except:
            print 'Missing requirement: ' + req
            return False
    return True

def validate_url(url):
    regex = re.compile(
            r'^(?:http|ftp)s?://' # http:// or https:// or ftp:// or ftps://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    match = regex.search(url)
    return True if match else False

def usage():
    pass

def exe_shell_commands(commands=None):
    if commands is None:
        commands = []
    for com in commands:
        try:
            if 'cd' in com:
                os.chdir(shlex.split(com)[1])
            else:
                call(shlex.split(com))
        except:
            return report_fail('Command `' + com + '` failed.')
    return True

def init(vim_config):
    missing_deps = []
    deps = vim_config[GBL][DPND]
    for dep in deps:
        if not check_requirements([dep[NAME]]):
            if not exe_shell_commands(dep[recipe]):
                missing_deps.append(dep[NAME])
    return missing_deps

def get_url_from_cmd_line(argv):
    git_url = ''
    for arg in argv:
        if validate_url(arg):
            git_url = arg
    return git_url

def __handle_install(argv, vim_config):
    if not argv:
        # No options and no git URL passed
        #TODO Interactively iterate and install each package in vim_config[PKGS]
        pass
    # Try to get git url
    git_url = get_url_from_cmd_line(argv)
    # Strip the git url from the rest of the options
    argv.remove(git_url)
    pkg_name = get_pkg_name_from_url(git_url)
    #TODO process cmd options, then install
    # Command line option for specifying pkg details VS installing from file

    pkg = [ p for p in vim_config[PKGS] if p[NAME] == pkg_name ]
    if pkg:
        vimpkg = dict_to_vimpkg(pkg[0])
    else:
        vimpkg = add_pkg(git_url, vim_config)
        save_vim_config(vim_config, vimpkg, VIM_CONFIG)
    install_pkg(vimpkg)


def dict_to_vimpkg(d):
    deps = [ dict_to_dep(dep) for dep in d[DPND] ]
    return VimPackage(d[PKG_URL], d[NAME], deps, d[RECIPE])

def dict_to_dep(d):
    return Dependency(d[NAME], d[RECIPE])

def __handle_add(argv, vim_config):
    install_target = get_install_target()
    git_url = get_url_from_cmd_line(argv)
    vimpkg = add_pkg(git_url, vim_config)
    save_vim_config(vim_config, vimpkg, VIM_CONFIG)

def __handle_remove(argv, vim_config):
    install_target = get_install_target()
    git_url = get_url_from_cmd_line(argv)
    if git_url:
        pkg_name = get_pkg_name_from_url(git_url)
    else:
        #TODO better checking for pkg_name location in args
        git_url = ''
        git_url = argv[len(argv)-1]
        pkg_name = git_url
        if not git_url:
            report_fail('No package URL specified. Exiting', confirm_continue=False)
            sys.exit(1)
    argv.remove(git_url)
    #TODO process cmd options

    msg = 'Confirm remove package `' + pkg_name + '`'
    if user_confirm(msg):
        vim_config[PKGS] = remove_pkg(pkg_name, git_url, install_target, vim_config)
        save_vim_config(vim_config, file_path=VIM_CONFIG)
        print 'Successfully removed package `' + pkg_name + '`'
    else:
        print 'Skipped removal of `' + pkg_name +'`'

def __handle_update(argv, vim_config):
    pass

MODES = { 'install': __handle_install, 'remove': __handle_remove, \
        'update': __handle_update, 'add': __handle_add }

def process_cmd_args(vim_config):
    argv = sys.argv[1:]
    argc = len(argv)
    mode = argv[0].lower()
    if mode not in MODES:
        usage()
        sys.exit()
    else:
        MODES[mode](argv[1:], vim_config)

def usage():
    pass

def main():
    vim_config = load_vim_config()
    missing_dependencies = init(vim_config)
    if missing_dependencies:
        print 'Cannot proceed. Missing the following dependencies that could' \
                + ' not be automatically insatlled:\n' \
                + str(missing_dependencies)

    process_cmd_args(vim_config)


if __name__ == '__main__':
    main()
